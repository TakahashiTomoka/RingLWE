#Fpの値のみに注目して攻撃を行う。
#ただし、m >= 3 とする。(最後にシークレットを推測する関係) 

from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler
import random
import sys
import numpy as np
import csv
from scipy import stats
load_attach_path('C:\\scripts\\sage')
load('subcycsampler.sage','misc.sage','ExtendCyclotomic.sage')


p = 11
d = 507
q = 67
f = 6
ff = 2 #中間体の拡大次数
r0 = 7.0
numsamples = q*10
alpha = 1 /(10*q^f)
chi2_value = stats.chi2.ppf(1-alpha, q-1)

print ('p = {}, d = {}, q = {}, f = {}' .format(p, d, q, f))
print ('r0 = {}'.format(r0))
print ('number of samples = {}'.format(numsamples))
print('chi2 parametor a= {}'.format(float(alpha)))

ZXq.<XX, YY> = GF(q)['XX,YY'] # polynomial ring
OKq.<X,Y> = ZXq.quo(cyclotomic_polynomial(p)(XX)).quo(YY^f-d) # ring of integer of Q(zeta_p)+Q(sqrt(d))
OKq_basis = [X^i * Y^j for j in range(f) for i in range(p-1)]
OKq_deg = f*(p-1)
cycmodq = ZXq(cyclotomic_polynomial(p)(XX)) # cyclotomic polynomial over Zq
fact = [fac[0] for fac in cycmodq.factor()] # prime ideal decomposition of ideal generated by q over OKq
F = OKq.base_ring()

#efile = r"C:\scripts\sage\samples\e_samples_p11_d507_q67_f6_r7.csv"
#afile = r"C:\scripts\sage\samples\a_samples_p11_d507_q67_f6_r7.csv"
#arandomfile = r"C:\scripts\sage\samples\a_random_samples_p11_d507_q67_f6_r7.csv"
#sfile = r"C:\scripts\sage\samples\s_samples_p11_d507_q67_f6_r7.csv"

def _my_dot_product(lst1,lst2):
    return sum([a*b for a,b in zip(lst1,lst2)])

def trace(x, m, n):
    """The Trace map: F_{q^m} -> F_{q^n}"""
    return sum([x^(q^(n*i)) for i in range(m//n)])

#多項式のすべての係数を取得
def get_coef_all(x, gen, n):
    return [x.lift().coefficient({gen: i}) for i in range(n)]

#yq^nの係数を取得
def get_coef(x, gen,n):
    return x.lift().coefficient({gen: n})



print('sampling start...')
# e #エラーの取り方確認
ecoeffs = []
S = ExtendCyclotomic(p, d, f, r0)
ecoeffs = [S(False) for _ in range(numsamples)]
np.savetxt('e_samples_p{}_d{}_q{}_f{}_r{}(2).csv'.format(p,d,q,f,r0), ecoeffs, delimiter =",",fmt ='% s')
#with open(efile) as file:
#    reader =  csv.reader(file)
#    ecoeffs = [[int(v) for v in row]for row in reader]

errors = [_my_dot_product(c, OKq_basis) for c in ecoeffs]

# a, s
#aはTr(6→2)が整数になるよう、Yq^3の係数が0になるように制限（f=6でTr(y)が整数になるにはyのYq^3の係数が0になればよい）
acoeffs_random = [[F.random_element() for i in range(OKq_deg)] for _ in range(numsamples)]
acoeffs = [[F.random_element() if i < 2*(p-1) or i >=3*(p-1)  else F(0) for i in range(OKq_deg)] for j in range(numsamples)]

np.savetxt('a_random_samples_p{}_d{}_q{}_f{}_r{}(2).csv'.format(p,d,q,f,r0), acoeffs_random, delimiter =",",fmt ='% s')
np.savetxt('a_samples_p{}_d{}_q{}_f{}_r{}(2).csv'.format(p,d,q,f,r0), acoeffs, delimiter =",",fmt ='% s')

#with open(arandomfile) as file:
#    reader =  csv.reader(file)
#    acoeffs_random = [[int(v) for v in row]for row in reader]
#with open(afile) as file:
#    reader =  csv.reader(file)
#    acoeffs = [[int(v) for v in row]for row in reader]

alst = [_my_dot_product(c, OKq_basis) for c in acoeffs]
alst_random = [_my_dot_product(c, OKq_basis) for c in acoeffs_random]

scoeffs = [F.random_element() for i in range(OKq_deg)]
np.savetxt('s_samples_p{}_d{}_q{}_f{}_r{}(2).csv'.format(p,d,q,f,r0), scoeffs, delimiter =",",fmt ='% s')
#with open(sfile) as file:
#    reader =  csv.reader(file)
#    scoeffs = [int(row[0]) for row in reader]

s = _my_dot_product(scoeffs, OKq_basis)

# b
blst = [a*s + e for a,e in zip(alst, errors)]
blst_random = [a*s + e for a,e in zip(alst_random, errors)]

print('sampling finished...')



# The Trace attack
print('Trace attack using a coeff beginning.')
successCnt = 0 
SUCCESS = False

totaltime = cputime()
for fac in fact:
    idealtime = cputime()
    print('------------------------------')
    print('ideal polynomial: {}'.format(fac))
    OKqq.<Xq,Yq> = OKq.quo(fac)
    rho = OKqq.convert_map_from(OKq)  
    Fqf = F^(f - ff)
    Fqff = F^(ff-1)
    smodq = rho(s)
    smodqTr = trace(smodq, f,1)
    print('rho(s) = {}'.format(smodq))
    print('Tr(rho(s)) = {}'.format(smodqTr))


    amodqlst = [rho(a) for a in alst]
    amodqlst_random = [rho(a) for a in alst_random]
    bmodqlst = [rho(b) for b in blst]
    bmodqlst_random = [rho(b) for b in blst_random]


    guess = Fqf.0
    count = 0
    Tr_s0 = 0
    s0 = 0
    chi2_record = 0
    x = Yq

    Tr_aa = [get_coef(aa,Yq,f-1) for aa in amodqlst]
    Tr_bb = [get_coef(bb,Yq,f-1) for bb in bmodqlst]
 
    
    for tt in Fqf:
        #代表元生成
        t = 0
        j = 0
        for i in range(f):
            if i % (f//ff) ==0:
                j += 1
                continue
            t += tt[i-j] * Yq^i

        success = True
        Mj = []
        for aa, aa_Tr, bb_Tr in zip(amodqlst, Tr_aa, Tr_bb):
            if aa_Tr == 0 :
                continue
            at_Tr = get_coef(aa*t, Yq, f-1)
            mj = (bb_Tr - at_Tr)/aa_Tr
            if mj not in F:
                success = False
                break
            Mj.append(F(mj))

        if not success or len(Mj) == 0 :
            break


        hist = {}
        for mj in Mj:
            if mj in hist:
                hist[mj] += 1
            else:
                hist[mj] =1
        E = len(Mj) // q
        chi2 = 0
        for chi in hist.values():
            chi2 += (chi-E)^2
        chi2 = chi2/E

        if chi2 > chi2_value:
            count +=1
            s0_guess = max(hist, key = hist.get)
            print('mj is not uniform. guess is {}.'.format(t))
            print('the guess of the Tr(s0) is {}.'.format(s0_guess))
            if chi2 > chi2_record:
                chi2_record = chi2
                guess = t
                Tr_s0 = s0_guess




    chi2_record = 0
    guess_s = 0
    if count >=1:
        for gg in Fqff:
            #シークレットの値の推測
        #    g = Tr_s0/ff + guess
            g = Tr_s0 + guess
            j = 1
            for i in range(1,f):
                if i % (f/ff) !=0:
                    j +=1
                    continue
                else:
                    g += gg[i-j]*Yq^i

            M = []
            for aa, bb in zip(amodqlst_random, bmodqlst_random):
                ee = bb - aa*g
                m = get_coef(ee, Yq, f-1)
                if m not in F:
                    break
                M.append(m)


            if len(M) == 0 :
                break
        
            hist = {}
            for m in M:
                if m in hist:
                    hist[m] += 1
                else:
                    hist[m] =1
            E = len(M) // q
            chi2 = 0
            for chi in hist.values():
                chi2 += (chi-E)^2
            chi2 = chi2/E

            if chi2 > chi2_value:
                print('ee is not uniform. g is {}.'.format(g))
                if chi2 > chi2_record:
                    chi2_record = chi2
                    guess_s = g

    

   
    if success and count == 1 :
        SUCCESS = True
        successCnt += 1 
        print('attack successful on {}'.format(fac))
        print('guess is {}'.format(guess_s))
    elif success and count > 1 :
        print('attack successful(?) on {}'.format(fac))
        print('Final guess is {}'.format(guess_s))
    else:
        print('attack failure.')
        print('NOT-RLWE')
    print('attack time on {}: {}'.format(fac, cputime(idealtime)))

    

#全イデアル終了
print ('#'*40) 
print ('Summary:')
print ('p = {}, q = {}, d = {}, f = {}' .format(p, q, d, f))
print ('r0 = {}'.format(r0))
print ('number of samples = {}'.format(numsamples))
print ('success? : %s'%SUCCESS)
print ('success count = {}'.format(successCnt))
print ('Total Time = {}(totaltime)'.format(cputime))