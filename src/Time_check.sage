#This is the program to check the time of ”Trace Attack”


from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler
import random
import sys
import numpy as np
from scipy import stats
load_attach_path('C:\\scripts\\sage')
load('subcycsampler.sage','misc.sage','ExtendCyclotomic.sage')


p = 13
d = 4872
q = 157
f = 3
r0 = 9.2
numsamples = q*10
alpha = 1 /(10*q^f)

chi2_value = stats.chi2.ppf(1-alpha, q-1)

print ('p = {}, q = {}, d = {}, f = {}' .format(p, q, d, f))
print ('r0 = {}'.format(r0))
print ('number of samples = {}'.format(numsamples))
print('chi2 parametor a= {}'.format(float(alpha)))

ZXq.<XX, YY> = GF(q)['XX,YY'] # polynomial ring
OKq.<X,Y> = ZXq.quo(cyclotomic_polynomial(p)(XX)).quo(YY^f-d) # ring of integer of Q(zeta_p)+Q(sqrt(d))
OKq_basis = [X^i * Y^j for j in range(f) for i in range(p-1)]
OKq_deg = f*(p-1)
cycmodq = ZXq(cyclotomic_polynomial(p)(XX)) # cyclotomic polynomial over Zq
fact = [fac[0] for fac in cycmodq.factor()] # prime ideal decomposition of ideal generated by q over OKq

def _my_dot_product(lst1,lst2):
    return sum([a*b for a,b in zip(lst1,lst2)])

# e #エラーの取り方確認
ecoeffs = []
S = ExtendCyclotomic(p, d, f, r0)
ecoeffs = [S(False) for _ in range(numsamples)]
errors = [_my_dot_product(c, OKq_basis) for c in ecoeffs]

# a, s
F = OKq.base_ring()
acoeffs = [[F.random_element() for i in range(OKq_deg)] for _ in range(numsamples)]
scoeffs = [F.random_element() for i in range(OKq_deg)]
alst = [_my_dot_product(c, OKq_basis) for c in acoeffs]
s = _my_dot_product(scoeffs, OKq_basis)
# b
blst = [a*s + e for a,e in zip(alst, errors)]



# The coset attack
print('attack beginning.')

def trace(x, n):
    """The Trace map: F_{q^n} -> F_{q}"""
    return sum([x^(q^i) for i in range(n)])




setuptime = cputime()
fac = fact[0]

print('------------------------------')
print('ideal polynomial: {}'.format(fac))
OKqq.<Xq,Yq> = OKq.quo(fac)
rho = OKqq.convert_map_from(OKq)  
Fqf = F
smodq = rho(s)
print('rho(s) = {}'.format(smodq))


amodqlst = [rho(a) for a in alst]
bmodqlst = [rho(b) for b in blst]


guess = Fqf.0
count = 0 
s0 = 0
x = Yq

Tr_aa = [trace(x*aa,f) for aa in amodqlst]
Tr_bb = [trace(x*bb,f) for bb in bmodqlst]

print ('setup Time = {}(setuptime)'.format(cputime))
    
idealtime = cputime()
for t in Fqf:
    success = True
    Tr_mj = []
    for aa, aa_Tr, bb_Tr in zip(amodqlst, Tr_aa, Tr_bb):
        if aa_Tr == 0 :
            continue
        at_Tr = trace(x*aa*t,f)
        mij = (bb_Tr - at_Tr)/aa_Tr
        if mij not in F:
            success = False
            break
        Tr_mj.append(F(mij))

    if not success or len(Tr_mj) == 0 :
        break


    hist = {}
    for tr_mj in Tr_mj:
        if tr_mj in hist:
            hist[tr_mj] += 1
        else:
            hist[tr_mj] =1
    E = len(Tr_mj) // q
    chi2 = 0
    for chi in hist.values():
        chi2 += (chi-E)^2
    chi2 = chi2/E

    if chi2 > chi2_value:
        print('{} is not uniform'.format(t))
    else:
        print('{} is uniform'.format(t))
    
print('attack time on {} of F: {}'.format(fac, cputime(idealtime)))

    





