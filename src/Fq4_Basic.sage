from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler
import random
import sys
import numpy as np
import csv
from scipy import stats
load_attach_path('C:\\scripts\\sage')
load('subcycsampler.sage','misc.sage','ExtendCyclotomic.sage')


p = 13
d = 503
q = 53
f = 4
ff = 2 #degree of subfield
r0 = 5
numsamples = q*10
alpha = 1 /(10*q^f)

chi2_value = stats.chi2.ppf(1-alpha, q-1)

print ('p = {}, d = {}, q = {}, f = {}' .format(p, d, q, f))
print ('r0 = {}'.format(r0))
print ('number of samples = {}'.format(numsamples))
print('chi2 parametor a= {}'.format(float(alpha)))

ZXq.<XX, YY> = GF(q)['XX,YY'] # polynomial ring
OKq.<X,Y> = ZXq.quo(cyclotomic_polynomial(p)(XX)).quo(YY^f-d) # ring of integer of Q(zeta_p)+Q(sqrt(d))
OKq_basis = [X^i * Y^j for j in range(f) for i in range(p-1)]
OKq_deg = f*(p-1)
cycmodq = ZXq(cyclotomic_polynomial(p)(XX)) # cyclotomic polynomial over Zq
fact = [fac[0] for fac in cycmodq.factor()] # prime ideal decomposition of ideal generated by q over OKq
F = OKq.base_ring()


def _my_dot_product(lst1,lst2):
    return sum([a*b for a,b in zip(lst1,lst2)])

def trace(x, m, n):
    """The Trace map: F_{q^m} -> F_{q^n}"""
    return sum([x^(q^(n*i)) for i in range(m//n)])



print('sampling start...')
# e 
ecoeffs = []
S = ExtendCyclotomic(p, d, f, r0)
ecoeffs = [S(False) for _ in range(numsamples)]
errors = [_my_dot_product(c, OKq_basis) for c in ecoeffs]

# a, s
acoeffs_random = [[F.random_element() for i in range(OKq_deg)] for _ in range(numsamples)]
acoeffs = [[F.random_element() if i < p-1 or i >= 2*(p-1) else F(0) for i in range(OKq_deg)] for j in range(numsamples)]
alst = [_my_dot_product(c, OKq_basis) for c in acoeffs]
alst_random = [_my_dot_product(c, OKq_basis) for c in acoeffs_random]

scoeffs = [F.random_element() for i in range(OKq_deg)]
s = _my_dot_product(scoeffs, OKq_basis)

# b
blst = [a*s + e for a,e in zip(alst, errors)]
blst_random = [a*s + e for a,e in zip(alst_random, errors)]

print('sampling finished...')


# The Trace attack
print('Trace attack beginning.')

successCnt = 0 
SUCCESS = False
totaltime = cputime()
for fac in fact:
    idealtime = cputime()
    print('------------------------------')
    print('ideal polynomial: {}'.format(fac))
    OKqq.<Xq,Yq> = OKq.quo(fac)
    rho = OKqq.convert_map_from(OKq)  
    Fqf = F^(f-ff)
    Fqff = F^(ff-1)
    smodq = rho(s)
    print('rho(s) = {}'.format(smodq))


    amodqlst = [rho(a) for a in alst]
    amodqlst_random = [rho(a) for a in alst_random]
    bmodqlst = [rho(b) for b in blst]
    bmodqlst_random = [rho(b) for b in blst_random]
    

    guess = Fqf.0
    count = 0
    Tr_s0 = 0
    s0 = 0
    chi2_record = 0
    x = Yq



    Tr_aa = [trace(x*aa,f,ff) for aa in amodqlst]
    Tr_bb = [trace(x*bb,f,ff) for bb in bmodqlst]
 
    
    for tt in Fqf:
        t = 0
        j = 0
        for i in range(f):
            if i % (f//ff) ==0:
                j += 1
                continue
            t += tt[i-j] * Yq^i
        success = True
        Tr_mj = []
        for aa, aa_Tr, bb_Tr in zip(amodqlst, Tr_aa, Tr_bb):
            if aa_Tr == 0 :
                continue
            at_Tr = trace(x*aa*t, f, ff)
            mij = (bb_Tr - at_Tr)/aa_Tr
            tr_mj = trace(mij,ff,1)
            if tr_mj not in F:
                success = False
                break
            Tr_mj.append(F(tr_mj))

        if not success or len(Tr_mj) == 0 :
            break


        hist = {}
        for tr_mj in Tr_mj:
            if tr_mj in hist:
                hist[tr_mj] += 1
            else:
                hist[tr_mj] =1
        E = len(Tr_mj) // q
        chi2 = 0
        for chi in hist.values():
            chi2 += (chi-E)^2
        chi2 = chi2/E

        if chi2 > chi2_value:
            count +=1
            s0_guess = max(hist, key = hist.get)
            print('tr_mj is not uniform. guess is {}.'.format(t))
            print('the guess of the Tr(s0) is {}.'.format(s0_guess))
            if chi2 > chi2_record:
                chi2_record = chi2
                guess = t
                Tr_s0 = s0_guess




    chi2_record = 0
    if count >=1:
        for gg in F:
            g = Tr_s0/ff + guess
            j = 0
            for i in range(1,f):
                if i % (f/ff) !=0:
                    j +=1
                    continue
                else:
                    g += gg*Yq^i
        
        

            M = []
            for aa, bb in zip(amodqlst_random, bmodqlst_random):
                ee = bb - aa*g
                m = trace(ee*x, f, 1)
                if m not in F:
                    break
                M.append(m)


            if len(M) == 0 :
                break
        
            hist = {}
            for m in M:
                if m in hist:
                    hist[m] += 1
                else:
                    hist[m] =1
            E = len(M) // q
            chi2 = 0
            for chi in hist.values():
                chi2 += (chi-E)^2
            chi2 = chi2/E

            if chi2 > chi2_value:
            #    s0_guess = max(hist, key = hist.get)
                print('ee is not uniform. g is {}.'.format(g))
                if chi2 > chi2_record:
                    chi2_record = chi2
                    guess_s = g

    

   
    if success and count == 1 :
        SUCCESS = True
        #guess_s = guess + s0
        successCnt += 1 
        print('attack successful on {}'.format(fac))
        print('guess is {}'.format(guess_s))
    elif success and count > 1 :
        print('attack failure.')
        #print('few samples.')
        #guess_s = guess + s0
        print('guess is {}'.format(guess_s))
    else:
        print('attack failure.')
        print('NOT-RLWE')
    print('attack time on {}: {}'.format(fac, cputime(idealtime)))

    

# end of all attacks over the finite field
print ('#'*40) 
print ('Summary:')
print ('p = {}, q = {}, d = {}, f = {}' .format(p, q, d, f))
print ('r0 = {}'.format(r0))
print ('number of samples = {}'.format(numsamples))
print ('success? : %s'%SUCCESS)
print ('success count = {}'.format(successCnt))
print ('Total Time = {}(totaltime)'.format(cputime))




