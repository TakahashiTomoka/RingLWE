from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler
import random
import sys
import numpy as np
from scipy import stats
load_attach_path('C:\\scripts\\sage')
load('subcycsampler.sage','misc.sage','ExtendCyclotomic.sage')


p = 11
q = 10
d = 503
f = 3
r0 = 4
numsamples = (q^f)*10

S = ExtendCyclotomic(p, d, f, r0)

alpha = 1 /(10*q^f)
chi2_value = stats.chi2.ppf(1-alpha, (q^f)-1)

print ('p = {}, q = {}, d = {}, f = {}' .format(p, q, d, f))
print ('number of samples = {}'.format(numsamples))
print ('r0 = {}'.format(r0))
print('chi2 parametor a= {}'.format(float(alpha)))

ZXq.<XX, YY> = GF(q)['XX,YY'] # polynomial ring
OKq.<X,Y> = ZXq.quo(cyclotomic_polynomial(p)(XX)).quo(YY^f-d) # ring of integer of Q(zeta_p)+Q(sqrt(d))
OKq_basis = [X^i * Y^j for j in range(f) for i in range(p-1)]
OKq_deg = f*(p-1)
cycmodq = ZXq(cyclotomic_polynomial(p)(XX)) # cyclotomic polynomial over Zq
fact = [fac[0] for fac in cycmodq.factor()] # prime ideal decomposition of ideal generated by q over OKq

def _my_dot_product(lst1,lst2):
    return sum([a*b for a,b in zip(lst1,lst2)])

print("sampling start.")
F = OKq.base_ring()

# e 
ecoeffs = []
S = ExtendCyclotomic(p, d, f, r0)
ecoeffs = [S(False) for _ in range(numsamples)]
errors = [_my_dot_product(c, OKq_basis) for c in ecoeffs]


# a, s
acoeffs = [[F.random_element() for i in range(OKq_deg)] for _ in range(numsamples)]
scoeffs = [F.random_element() for i in range(OKq_deg)]
alst = [_my_dot_product(c, OKq_basis) for c in acoeffs]
s = _my_dot_product(scoeffs, OKq_basis)
# b
blst = [a*s + e for a,e in zip(alst, errors)]

print("sampling finished.")



# The chi2 attack
print('chi2 attack beginning.')

successCnt = 0 
SUCCESS = False
#totaltime = cputime()


#for fac in fact:
fac = fact[0]
idealtime = cputime()
print('------------------------------')
print('ideal polynomial: {}'.format(fac))
OKqq.<Xq,Yq> = OKq.quo(fac)
OKqq_basis = [Yq^i for i in range(f)]
rho = OKqq.convert_map_from(OKq)  
Fqff = F^f
Fqf = F
smodq = rho(s)
print('rho(s) = {}'.format(smodq))


time = cputime()
amodqlst = [rho(a) for a in alst]
bmodqlst = [rho(b) for b in blst]


acoeffs = [[F.random_element() for i in range(f)] for _ in range(numsamples)]
alst = [_my_dot_product(c, OKqq_basis) for c in acoeffs]


print("reduction time :{}".format(cputime(time)))

guess = Fqf.0
count = 0 
s0 = 0

source = []
for tt in Fqff:
    g = 0
    for i in range(f):
        g += tt[i] * Yq^i
    source.append(g)



idealtime = cputime()
for g in Fqf:    
    success = True
    Tr_mj = []
    for aa, bb in zip(amodqlst, bmodqlst):
        mij = bb - aa*g
        Tr_mj.append(mij)

    if not success or len(Tr_mj) == 0 :
        break


    hist = dict.formkeys(source,0)
    for tr_mj in Tr_mj:
        if tr_mj in hist:
            hist[tr_mj] += 1
        else:
            hist[tr_mj] =1
    E = len(Tr_mj) // (q^f)
    chi2 = 0
    for chi in hist.values():
        chi2 += (chi-E)^2
    chi2 = chi2/E
    
    if chi2 > chi2_value:
        count +=1
        guess = g
        print('mj is not uniform. guess is {}.'.format(g))
    if chi2 > chi2_value:
        print("{} is not uniform.".format(g))
    else:
        print("{} is uniform.".format(g))
            
        
    if success and count == 1 :
        SUCCESS = True
        successCnt += 1 
        print('attack successful on {}'.format(fac))
        print('guess is {}'.format(guess))
    elif success and count > 1 :
        print('attack failure.')
        print('few samples.')
    else:
        print('attack failure.')
        print('NOT-RLWE')
    print('attack time on {} of F: {}'.format(fac, cputime(idealtime)))

    

# end of all attacks over the finite field
#print ('#'*40) 
#print ('Summary:')
#print ('p = {}, q = {}, d = {}, f = {}' .format(p, q, d, f))
#print ('r0 = {}'.format(r0))
#print ('number of samples = {}'.format(numsamples))
#print ('success? : %s'%SUCCESS)
#print ('success count = {}'.format(successCnt))
#print ('Total Time = {}(totaltime)'.format(cputime))
