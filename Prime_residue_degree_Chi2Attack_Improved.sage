from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler
import random
import sys
import csv
import numpy as np
from scipy import stats
load('sampling/subcycsampler.sage','sampling/misc.sage','sampling/ExtendCyclotomic.sage')


p = 11
d = 504
q = 67
f = 3
r0 = 4.1
numsamples = 10*q
alpha = 1 /(10*q^f)
chi2_value = stats.chi2.ppf(1-alpha, q-1)

print ('p = {}, d = {}, q = {}, f = {}' .format(p, d, q, f))
print ('r0 = {}'.format(r0))
print ('number of samples = {}'.format(numsamples))
print('chi2 parametor a= {}'.format(float(alpha)))

ZXq.<XX, YY> = GF(q)['XX,YY'] # polynomial ring
OKq.<X,Y> = ZXq.quo(cyclotomic_polynomial(p)(XX)).quo(YY^f-d) # ring of integer of Q(zeta_p)+Q(sqrt(d))
OKq_basis = [X^i * Y^j for j in range(f) for i in range(p-1)]
OKq_deg = f*(p-1)
cycmodq = ZXq(cyclotomic_polynomial(p)(XX)) # cyclotomic polynomial over Zq
fact = [fac[0] for fac in cycmodq.factor()] # prime ideal decomposition of ideal generated by q over OKq
F = OKq.base_ring()




def _my_dot_product(lst1,lst2):
    return sum([a*b for a,b in zip(lst1,lst2)])

def trace(x, n):
    """The Trace map: F_{q^n} -> F_{q}"""
    return sum([x^(q^i) for i in range(n)])

#Get all coefficients of a polynomial of degree n
def get_coef_all(x, gen, n):
    return [x.lift().coefficient({gen: i}) for i in range(n)]

#Get the yq^n coefficient of the polynomial 
def get_coef(x, gen,n):
    return x.lift().coefficient({gen: n})



print('sampling start...')
# e 
ecoeffs = []
S = ExtendCyclotomic(p, d, f, r0)
ecoeffs = [S(False) for _ in range(numsamples)]
errors = [_my_dot_product(c, OKq_basis) for c in ecoeffs]


# a, s
acoeffs = [[F.random_element() for i in range(OKq_deg)] for _ in range(numsamples)]
alst = [_my_dot_product(c, OKq_basis) for c in acoeffs]

scoeffs = [F.random_element() for i in range(OKq_deg)]
s = _my_dot_product(scoeffs, OKq_basis)


# b
blst = [a*s + e for a,e in zip(alst, errors)]

print('sampling finished...')



# The Trace attack
print('Trace attack using a coeff beginning.')
successCnt = 0 
SUCCESS = False
totaltime = cputime()
for fac in fact:
    idealtime = cputime()
    print('------------------------------')
    print('ideal polynomial: {}'.format(fac))
    OKqq.<Xq,Yq> = OKq.quo(fac)
    rho = OKqq.convert_map_from(OKq)  
    Fqf = F^(f-1)
    smodq = rho(s)
    print('rho(s) = {}'.format(smodq))


    amodqlst = [rho(a) for a in alst]
    bmodqlst = [rho(b) for b in blst]


    guess = Fqf.0
    count = 0 
    s0 = 0
    chi2_record = 0
    x = Yq

    Tr_aa = [get_coef(aa,Yq,f-1) for aa in amodqlst]
    Tr_bb = [get_coef(bb,Yq,f-1) for bb in bmodqlst]
 
    #Tr_aa = [coeff(aa) for aa in amodqlst]
    #Tr_bb = [coeff(bb) for bb in bmodqlst]
 

    for tt in Fqf:
        t = 0
        for i in range(1,f):
            t += tt[i-1] * Yq^i

        success = True
        Mj = []
        for aa, aa_Tr, bb_Tr in zip(amodqlst, Tr_aa, Tr_bb):
            if aa_Tr == 0 :
                continue
            at_Tr = get_coef(aa*t, Yq, f-1)
            mj = (bb_Tr - at_Tr)/aa_Tr
            if mj not in F:
                success = False
                break
            Mj.append(F(mj))

        if not success or len(Mj) == 0 :
            break


        hist = {}
        for mj in Mj:
            if mj in hist:
                hist[mj] += 1
            else:
                hist[mj] =1
        E = len(Mj) // q
        chi2 = 0
        for chi in hist.values():
            chi2 += (chi-E)^2
        chi2 = chi2/E

        if chi2 > chi2_value:
            count +=1
            s0_guess = max(hist, key = hist.get)
            print('mj is not uniform. guess is {}.'.format(t))
            print('the guess of the s0 is {}.'.format(s0_guess))
            if chi2 > chi2_record:
                chi2_record = chi2
                guess = t
                s0 = s0_guess 

        
    if success and count == 1 :
        SUCCESS = True
        guess_s = guess + s0
        successCnt += 1 
        print('attack successful on {}'.format(fac))
        print('guess is {}'.format(guess_s))
    elif success and count > 1 :
        #print('attack failure.')
        #print('few samples.')
        print('attack successful(?) on {}'.format(fac))
        guess_s = guess + s0
        print('Final guess is {}'.format(guess_s))
    else:
        print('attack failure.')
        print('NOT-RLWE')
    print('attack time on {}: {}'.format(fac, cputime(idealtime)))

    

# end of all attacks over the finite field
print ('#'*40) 
print ('Summary:')
print ('p = {}, q = {}, d = {}, f = {}' .format(p, q, d, f))
print ('r0 = {}'.format(r0))
print ('number of samples = {}'.format(numsamples))
print ('success? : %s'%SUCCESS)
print ('success count = {}'.format(successCnt))
print ('Total Time = {}(totaltime)'.format(cputime))




